---
phase: 02-data-access
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/youtube/search.go
  - internal/server/server.go
  - internal/server/tools_search.go
autonomous: true

must_haves:
  truths:
    - "Claude can search YouTube for music videos by query and get video IDs, titles, and channel names"
    - "Claude can verify whether a specific video exists on YouTube by video ID"
    - "Search results are filtered to the Music category (videoCategoryId=10)"
    - "Search tool documents its quota cost (100 units) in the description"
  artifacts:
    - path: "internal/youtube/search.go"
      provides: "YouTube client methods for search and video verification"
      contains: "func (c *Client) SearchVideos"
    - path: "internal/server/tools_search.go"
      provides: "MCP tool handlers for search_videos and get_video"
      contains: "search_videos"
    - path: "internal/server/server.go"
      provides: "Search tool registration call in NewServer"
      contains: "registerSearchTools"
  key_links:
    - from: "internal/server/tools_search.go"
      to: "internal/youtube/search.go"
      via: "s.ytClient.SearchVideos, s.ytClient.GetVideo"
      pattern: "s\\.ytClient\\.(SearchVideos|GetVideo)"
    - from: "internal/server/server.go"
      to: "internal/server/tools_search.go"
      via: "s.registerSearchTools() call in NewServer"
      pattern: "s\\.registerSearchTools"
---

<objective>
Implement YouTube client methods and MCP tools for searching YouTube Music tracks and verifying video existence.

Purpose: These tools let Claude search for specific tracks to verify recommendations exist on YouTube Music, and look up video details by ID for playlist building. Search is the bridge between Claude's music knowledge and actual playable content on YouTube.

Output: Two MCP tools registered and functional: search_videos (100 units/call, music category filtered) and get_video (1 unit/call, verify by ID). Search is intentionally limited to first page only to conserve quota.
</objective>

<execution_context>
@/home/gxravel/.claude/get-shit-done/workflows/execute-plan.md
@/home/gxravel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-access/02-RESEARCH.md
@.planning/phases/02-data-access/02-01-SUMMARY.md

# Existing code to extend (will be modified by Plan 01 first)
@internal/youtube/client.go
@internal/server/server.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement YouTube client methods for search and video lookup</name>
  <files>internal/youtube/search.go</files>
  <action>
Create a new file with search and video verification methods on the youtube.Client.

**internal/youtube/search.go:**

Define types:

```go
type SearchResult struct {
    VideoID      string
    Title        string
    ChannelTitle string
    Description  string
}

type VideoDetail struct {
    ID           string
    Title        string
    ChannelTitle string
    Description  string
    Duration     string
    PublishedAt  string
}
```

Implement two methods:

1. `SearchVideos(ctx context.Context, query string, maxResults int64) ([]SearchResult, error)`:
   - Validate query is not empty (return error if so)
   - Default maxResults to 10 if <= 0, cap at 25 (single page only — each page costs 100 quota units, so NEVER paginate search)
   - Call `c.service.Search.List([]string{"snippet"}).Q(query).Type("video").VideoCategoryId("10").MaxResults(maxResults).Do()` — single page, no Pages()
   - Convert response items to []SearchResult: VideoID from `item.Id.VideoId`, Title from `item.Snippet.Title`, ChannelTitle from `item.Snippet.ChannelTitle`, Description from `item.Snippet.Description`
   - Wrap errors: `fmt.Errorf("search failed: %w", err)`

2. `GetVideo(ctx context.Context, videoID string) (*VideoDetail, error)`:
   - Validate videoID is not empty (return error if so)
   - Call `c.service.Videos.List([]string{"snippet", "contentDetails"}).Id(videoID).Do()`
   - If `len(resp.Items) == 0`, return `nil, nil` (video not found, not an error — caller checks for nil)
   - Convert first item to VideoDetail: ID, Title from Snippet.Title, ChannelTitle from Snippet.ChannelTitle, Description from Snippet.Description, Duration from ContentDetails.Duration (ISO 8601 format like "PT4M30S"), PublishedAt from Snippet.PublishedAt
   - Wrap errors: `fmt.Errorf("failed to get video: %w", err)`

Key design choices:
- Search is single-page only (no .Pages()) to avoid 100-unit-per-page cost
- videoCategoryId=10 filters to Music category (not perfect, but best available)
- GetVideo returns nil,nil for not-found (not an error) — this is the standard Go pattern for "not found" vs "error"
- GetVideo costs only 1 quota unit — intended for verifying specific track IDs before adding to playlists
  </action>
  <verify>Run `go build ./...` and `go vet ./...` — both must pass.</verify>
  <done>SearchVideos and GetVideo methods exist on youtube.Client with proper error handling, quota-efficient patterns, and Music category filtering.</done>
</task>

<task type="auto">
  <name>Task 2: Register MCP tools for search and video lookup, wire into server</name>
  <files>internal/server/tools_search.go, internal/server/server.go</files>
  <action>
Create MCP tool handlers for search and wire them into the server.

**internal/server/tools_search.go:**

Define input/output types with json and jsonschema struct tags:

```go
type searchVideosInput struct {
    Query      string `json:"query" jsonschema:"required,description=Search query (e.g. artist name + song title or general music query)"`
    MaxResults int64  `json:"maxResults" jsonschema:"description=Maximum results to return (default 10, max 25). WARNING: each search costs 100 API quota units,minimum=1,maximum=25"`
}

type searchResultInfo struct {
    VideoID      string `json:"videoId" jsonschema:"description=YouTube video ID (use with get_video or for playlist building)"`
    Title        string `json:"title" jsonschema:"description=Video title"`
    ChannelTitle string `json:"channelTitle" jsonschema:"description=Channel that uploaded the video"`
    Description  string `json:"description" jsonschema:"description=Video description snippet"`
}

type searchOutput struct {
    Results []searchResultInfo `json:"results"`
    Query   string             `json:"query" jsonschema:"description=The search query that was executed"`
    Count   int                `json:"count" jsonschema:"description=Number of results returned"`
}

type getVideoInput struct {
    VideoID string `json:"videoId" jsonschema:"required,description=YouTube video ID to look up"`
}

type videoDetailInfo struct {
    ID           string `json:"id" jsonschema:"description=YouTube video ID"`
    Title        string `json:"title" jsonschema:"description=Video title"`
    ChannelTitle string `json:"channelTitle" jsonschema:"description=Channel that uploaded the video"`
    Description  string `json:"description" jsonschema:"description=Video description"`
    Duration     string `json:"duration" jsonschema:"description=Video duration in ISO 8601 format (e.g. PT4M30S)"`
    PublishedAt  string `json:"publishedAt" jsonschema:"description=Video publish date"`
    Found        bool   `json:"found" jsonschema:"description=Whether the video was found"`
}
```

Register two tools via `s.registerSearchTools()` method:

1. **search_videos** — Description: "Search YouTube for music videos. Results are filtered to the Music category. WARNING: Each search costs 100 API quota units (daily limit is 10,000 units). Use sparingly — prefer get_video (1 unit) when you already have a video ID."
   - Input: searchVideosInput
   - Handler: calls `s.ytClient.SearchVideos(ctx, input.Query, input.MaxResults)`, converts to searchOutput
   - On error: return `nil, zero-output, err`
   - On success: return CallToolResult with TextContent summary + searchOutput

2. **get_video** — Description: "Look up a specific YouTube video by its ID. Returns video details including title, channel, duration, and whether it exists. Use this to verify a video exists before adding it to a playlist. Quota cost: 1 unit."
   - Input: getVideoInput
   - Handler: calls `s.ytClient.GetVideo(ctx, input.VideoID)`
   - If result is nil (not found): return videoDetailInfo with Found=false and TextContent "Video not found"
   - If result exists: return populated videoDetailInfo with Found=true

**internal/server/server.go:**

Add `s.registerSearchTools()` call in `NewServer` after the existing taste data registration calls (added by Plan 01):

```go
s.registerPlaylistTools()
s.registerSubscriptionTools()
s.registerSearchTools()  // Add this line
```

Follow the exact same pattern established in Plan 01 for tool registration (same mcp.AddTool approach, same handler signature, same error handling).
  </action>
  <verify>Run `go build ./...` and `go vet ./...` — both must pass. Verify that server.go now calls all three register methods: registerPlaylistTools, registerSubscriptionTools, registerSearchTools.</verify>
  <done>Two search MCP tools registered (search_videos, get_video). Server compiles with all six tools from both plans registered. Quota costs clearly documented in tool descriptions.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go vet ./...` reports no issues
3. `internal/youtube/search.go` contains SearchVideos and GetVideo methods
4. `internal/server/tools_search.go` registers search_videos and get_video tools
5. `internal/server/server.go` calls registerSearchTools() alongside the taste data registration calls
6. search_videos tool description warns about 100-unit quota cost
7. SearchVideos uses single-page .Do() not .Pages() (quota conservation)
8. GetVideo returns nil,nil for not-found (not an error)
</verification>

<success_criteria>
- Both search MCP tools compile and are registered in the server
- Search uses videoCategoryId=10 for Music category filtering
- Search is single-page only (never paginated) to conserve 100-unit-per-page quota
- get_video costs only 1 unit and clearly indicates found/not-found status
- Quota costs prominently documented in tool descriptions
- All six Phase 2 tools registered in server.go
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-access/02-02-SUMMARY.md`
</output>
