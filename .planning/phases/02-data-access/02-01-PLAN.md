---
phase: 02-data-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/youtube/playlists.go
  - internal/youtube/subscriptions.go
  - internal/server/server.go
  - internal/server/tools_playlists.go
  - internal/server/tools_subscriptions.go
autonomous: true

must_haves:
  truths:
    - "Claude can retrieve user's liked videos with video ID, title, and channel name"
    - "Claude can list user's playlists with playlist ID, title, and item count"
    - "Claude can retrieve contents of a specific playlist by playlist ID"
    - "Claude can retrieve user's channel subscriptions with channel ID and title"
  artifacts:
    - path: "internal/youtube/playlists.go"
      provides: "YouTube client methods for liked videos and playlist operations"
      contains: "func (c *Client) GetLikedVideos"
    - path: "internal/youtube/subscriptions.go"
      provides: "YouTube client method for subscriptions"
      contains: "func (c *Client) GetSubscriptions"
    - path: "internal/server/tools_playlists.go"
      provides: "MCP tool handlers for get_liked_videos, list_playlists, get_playlist_items"
      contains: "get_liked_videos"
    - path: "internal/server/tools_subscriptions.go"
      provides: "MCP tool handler for get_subscriptions"
      contains: "get_subscriptions"
    - path: "internal/server/server.go"
      provides: "Tool registration calls in NewServer"
      contains: "registerPlaylistTools"
  key_links:
    - from: "internal/server/tools_playlists.go"
      to: "internal/youtube/playlists.go"
      via: "s.ytClient.GetLikedVideos, s.ytClient.ListPlaylists, s.ytClient.GetPlaylistItems"
      pattern: "s\\.ytClient\\.(GetLikedVideos|ListPlaylists|GetPlaylistItems)"
    - from: "internal/server/tools_subscriptions.go"
      to: "internal/youtube/subscriptions.go"
      via: "s.ytClient.GetSubscriptions"
      pattern: "s\\.ytClient\\.GetSubscriptions"
    - from: "internal/server/server.go"
      to: "internal/server/tools_playlists.go"
      via: "s.registerPlaylistTools() call in NewServer"
      pattern: "s\\.registerPlaylistTools"
---

<objective>
Implement YouTube client methods and MCP tools for retrieving user taste data: liked videos, playlists (listing and contents), and channel subscriptions.

Purpose: These tools give Claude access to the user's YouTube Music taste profile — liked songs, curated playlists, and followed artists/channels — which Claude needs to analyze listening patterns and make personalized recommendations.

Output: Four MCP tools registered and functional: get_liked_videos, list_playlists, get_playlist_items, get_subscriptions. All use efficient pagination via Pages() method and cost 1 quota unit per page.
</objective>

<execution_context>
@/home/gxravel/.claude/get-shit-done/workflows/execute-plan.md
@/home/gxravel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-access/02-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-02-SUMMARY.md

# Existing code to extend
@internal/youtube/client.go
@internal/server/server.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement YouTube client methods for taste data retrieval</name>
  <files>internal/youtube/playlists.go, internal/youtube/subscriptions.go</files>
  <action>
Create two new files extending the youtube.Client with domain methods for taste data.

**internal/youtube/playlists.go:**

Define domain types in this file (no separate types package needed — keep types close to where they're used):

```go
type Video struct {
    ID           string
    Title        string
    ChannelTitle string
}

type Playlist struct {
    ID          string
    Title       string
    Description string
    ItemCount   int64
}
```

Define a package-level sentinel error for stopping pagination early:
```go
var errStopPagination = fmt.Errorf("stop pagination")
```

Implement three methods on `*Client`:

1. `GetLikedVideos(ctx context.Context, maxResults int64) ([]Video, error)`:
   - First call `c.service.Channels.List([]string{"contentDetails"}).Mine(true).Do()` to get the likes playlist ID from `Items[0].ContentDetails.RelatedPlaylists.Likes`
   - Then call `c.service.PlaylistItems.List([]string{"snippet"}).PlaylistId(likesPlaylistID).MaxResults(50).Pages(ctx, callback)` to retrieve items
   - In the callback: check `ctx.Err()` first, then append Video structs (ID from `item.Snippet.ResourceId.VideoId`, Title from `item.Snippet.Title`, ChannelTitle from `item.Snippet.VideoOwnerChannelTitle`)
   - Stop pagination when `len(videos) >= maxResults` by returning `errStopPagination`
   - After Pages(): if err is `errStopPagination`, clear it; otherwise propagate
   - Truncate result to maxResults length
   - Default maxResults to 50 if <= 0

2. `ListPlaylists(ctx context.Context, maxResults int64) ([]Playlist, error)`:
   - Call `c.service.Playlists.List([]string{"snippet", "contentDetails"}).Mine(true).MaxResults(50).Pages(ctx, callback)`
   - In callback: check `ctx.Err()`, append Playlist structs (ID, Title from Snippet.Title, Description from Snippet.Description, ItemCount from ContentDetails.ItemCount)
   - Stop pagination at maxResults via errStopPagination
   - Default maxResults to 25 if <= 0

3. `GetPlaylistItems(ctx context.Context, playlistID string, maxResults int64) ([]Video, error)`:
   - Validate playlistID is not empty (return error if so)
   - Call `c.service.PlaylistItems.List([]string{"snippet"}).PlaylistId(playlistID).MaxResults(50).Pages(ctx, callback)`
   - Same pattern as GetLikedVideos for pagination and video extraction
   - Default maxResults to 50 if <= 0

**internal/youtube/subscriptions.go:**

Define type:
```go
type Subscription struct {
    ChannelID   string
    Title       string
    Description string
}
```

Implement one method:

1. `GetSubscriptions(ctx context.Context, maxResults int64) ([]Subscription, error)`:
   - Call `c.service.Subscriptions.List([]string{"snippet"}).Mine(true).MaxResults(50).Pages(ctx, callback)`
   - In callback: check `ctx.Err()`, append Subscription structs (ChannelID from `item.Snippet.ResourceId.ChannelId`, Title from `item.Snippet.Title`, Description from `item.Snippet.Description`)
   - Stop pagination at maxResults via errStopPagination
   - Default maxResults to 25 if <= 0

All methods follow the same error handling pattern: wrap errors with `fmt.Errorf("failed to ...: %w", err)`. Use `errors.Is(err, errStopPagination)` for sentinel error checks (import "errors").
  </action>
  <verify>Run `go build ./...` and `go vet ./...` — both must pass with zero errors.</verify>
  <done>Four YouTube client methods exist (GetLikedVideos, ListPlaylists, GetPlaylistItems, GetSubscriptions) with proper pagination, context checking, and maxResults limiting.</done>
</task>

<task type="auto">
  <name>Task 2: Register MCP tools for taste data and wire into server</name>
  <files>internal/server/tools_playlists.go, internal/server/tools_subscriptions.go, internal/server/server.go</files>
  <action>
Create MCP tool handlers and register them in the server.

**internal/server/tools_playlists.go:**

Use `mcp.AddTool` (NOT the generic `mcp.AddTool[In, Out]` — check the actual SDK API; the research examples show the 3-arg handler pattern with typed input, but verify against the installed SDK). The handler receives `(ctx, req, input)` and returns `(*CallToolResult, Output, error)`.

Define input/output types with `json` and `jsonschema` struct tags:

```go
type getLikedVideosInput struct {
    MaxResults int64 `json:"maxResults" jsonschema:"description=Maximum number of liked videos to return (default 50),minimum=1,maximum=500"`
}

type videoInfo struct {
    ID           string `json:"id" jsonschema:"description=YouTube video ID"`
    Title        string `json:"title" jsonschema:"description=Video title"`
    ChannelTitle string `json:"channelTitle" jsonschema:"description=Channel that uploaded the video"`
}

type videosOutput struct {
    Videos []videoInfo `json:"videos"`
    Count  int         `json:"count" jsonschema:"description=Number of videos returned"`
}
```

Register three tools via `s.registerPlaylistTools()` method:

1. **get_liked_videos** — Description: "Retrieve the user's liked videos/songs from YouTube. These represent songs the user has explicitly liked. Quota cost: ~2 units."
   - Input: getLikedVideosInput
   - Handler: calls `s.ytClient.GetLikedVideos(ctx, input.MaxResults)`, converts []youtube.Video to videosOutput
   - On error: return `nil, zero-output, err`
   - On success: return `&mcp.CallToolResult` with TextContent summary + videosOutput

2. **list_playlists** — Description: "List all playlists on the user's YouTube account with their titles and track counts. Quota cost: ~1 unit per 50 playlists."
   - Input: `listPlaylistsInput` with MaxResults field (default 25, max 500)
   - Output: `playlistsOutput` with Playlists []playlistInfo and Count
   - playlistInfo: ID, Title, Description, ItemCount
   - Handler: calls `s.ytClient.ListPlaylists`

3. **get_playlist_items** — Description: "Retrieve the videos/tracks in a specific playlist by playlist ID. Use list_playlists first to get playlist IDs. Quota cost: ~1 unit per 50 items."
   - Input: `getPlaylistItemsInput` with PlaylistID (required) and MaxResults (default 50, max 500)
   - PlaylistID field: `json:"playlistId" jsonschema:"required,description=YouTube playlist ID (from list_playlists)"`
   - Output: videosOutput (same as get_liked_videos)
   - Handler: calls `s.ytClient.GetPlaylistItems`

**internal/server/tools_subscriptions.go:**

Register one tool via `s.registerSubscriptionTools()`:

1. **get_subscriptions** — Description: "Retrieve the user's channel subscriptions from YouTube. These represent artists and channels the user follows. Quota cost: ~1 unit per 50 subscriptions."
   - Input: `getSubscriptionsInput` with MaxResults (default 25, max 500)
   - Output: `subscriptionsOutput` with Subscriptions []subscriptionInfo and Count
   - subscriptionInfo: ChannelID, Title, Description
   - Handler: calls `s.ytClient.GetSubscriptions`

**internal/server/server.go:**

Modify `NewServer` to call tool registration methods AFTER creating the Server struct but BEFORE returning:

```go
s := &Server{
    mcpServer: mcpServer,
    logger:    logger,
    ytClient:  ytClient,
}

// Register MCP tools
s.registerPlaylistTools()
s.registerSubscriptionTools()

return s
```

For the mcp.AddTool call pattern: if the SDK's AddTool signature doesn't match the research examples exactly, adapt. The key requirement is that each tool gets a name, description, JSON schema for input, and a handler function. Check `go doc github.com/modelcontextprotocol/go-sdk/mcp.AddTool` during implementation to use the correct signature.

For handler return: if the SDK expects only `(*CallToolResult, error)` rather than `(*CallToolResult, Output, error)`, return a CallToolResult with TextContent containing JSON-marshaled output. Use `encoding/json.Marshal` and return as TextContent.
  </action>
  <verify>Run `go build ./...` and `go vet ./...` — both must pass. Then verify tool registration by checking that `NewServer` calls both `registerPlaylistTools` and `registerSubscriptionTools`.</verify>
  <done>Four MCP tools are registered (get_liked_videos, list_playlists, get_playlist_items, get_subscriptions) and wired into the server. Server compiles and starts with tools available.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go vet ./...` reports no issues
3. `internal/youtube/playlists.go` contains GetLikedVideos, ListPlaylists, GetPlaylistItems methods
4. `internal/youtube/subscriptions.go` contains GetSubscriptions method
5. `internal/server/tools_playlists.go` registers get_liked_videos, list_playlists, get_playlist_items tools
6. `internal/server/tools_subscriptions.go` registers get_subscriptions tool
7. `internal/server/server.go` calls registerPlaylistTools() and registerSubscriptionTools() in NewServer
</verification>

<success_criteria>
- All four taste data MCP tools compile and are registered in the server
- YouTube client methods use Pages() for automatic pagination with maxResults limiting
- Context cancellation is checked in pagination callbacks
- Tool input/output types have proper JSON and jsonschema struct tags
- Quota costs documented in tool descriptions
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-access/02-01-SUMMARY.md`
</output>
