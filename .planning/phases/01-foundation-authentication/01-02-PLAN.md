---
phase: 01-foundation-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/youtube/client.go
  - internal/server/server.go
  - cmd/server/main.go
autonomous: false

must_haves:
  truths:
    - "MCP server starts and communicates via stdio transport"
    - "Server authenticates with YouTube API before accepting MCP connections"
    - "Authenticated YouTube API call succeeds (Channels.List().Mine(true) returns channel name)"
    - "All logging goes to stderr, stdout is reserved for JSON-RPC only"
    - "Server exits cleanly on context cancellation or error"
  artifacts:
    - path: "internal/youtube/client.go"
      provides: "YouTube API service wrapper with auth validation"
      exports: ["Client", "NewClient", "ValidateAuth"]
    - path: "internal/server/server.go"
      provides: "MCP server setup with stdio transport"
      exports: ["Server", "NewServer", "Run"]
    - path: "cmd/server/main.go"
      provides: "Entry point wiring config, auth, youtube, and MCP server"
      contains: "func main()"
  key_links:
    - from: "cmd/server/main.go"
      to: "internal/config/config.go"
      via: "Loads config at startup"
      pattern: "config\\.Load"
    - from: "cmd/server/main.go"
      to: "internal/auth/oauth.go"
      via: "Runs OAuth2 authentication before server start"
      pattern: "auth\\.Authenticate"
    - from: "cmd/server/main.go"
      to: "internal/youtube/client.go"
      via: "Creates YouTube client with authenticated HTTP client"
      pattern: "youtube\\.NewClient"
    - from: "cmd/server/main.go"
      to: "internal/server/server.go"
      via: "Creates and runs MCP server"
      pattern: "server\\.NewServer"
    - from: "internal/youtube/client.go"
      to: "google.golang.org/api/youtube/v3"
      via: "Wraps YouTube API service"
      pattern: "youtube\\.NewService"
    - from: "internal/server/server.go"
      to: "github.com/modelcontextprotocol/go-sdk/mcp"
      via: "Creates MCP server with stdio transport"
      pattern: "mcp\\.NewServer"
---

<objective>
Wire together the YouTube API client, MCP server, and main entry point so the server authenticates on startup and runs as a functioning MCP server over stdio.

Purpose: Complete the Phase 1 foundation — a running MCP server that proves YouTube API access works end-to-end. This is the minimal viable server that Phase 2 will add tools to.
Output: Runnable `cmd/server/main.go` that authenticates via OAuth2, validates YouTube API access, and starts MCP server on stdio.
</objective>

<execution_context>
@/home/gxravel/.claude/get-shit-done/workflows/execute-plan.md
@/home/gxravel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create YouTube API client wrapper and MCP server with main entry point</name>
  <files>internal/youtube/client.go, internal/server/server.go, cmd/server/main.go</files>
  <action>
    **internal/youtube/client.go:**

    Create `Client` struct wrapping `*youtube.Service`:
    - Field: `service *youtube.Service`
    - Constructor: `NewClient(ctx context.Context, httpClient *http.Client) (*Client, error)` — creates YouTube service via `youtube.NewService(ctx, option.WithHTTPClient(httpClient))`, wraps in Client struct

    Create `ValidateAuth(ctx context.Context) (string, error)`:
    - Call `service.Channels.List([]string{"snippet"}).Mine(true).Do()` (costs 1 quota unit)
    - If error, return wrapped error: `"auth validation failed: %w"`
    - If no items returned, return error: `"no channel found for authenticated user"`
    - Return channel title from `resp.Items[0].Snippet.Title`

    **internal/server/server.go:**

    Create `Server` struct:
    - Fields: `mcpServer *mcp.Server`, `logger *slog.Logger`, `ytClient *youtube.Client` (import from internal/youtube)
    - Constructor: `NewServer(logger *slog.Logger, ytClient *youtube.Client) *Server`:
      - Create MCP server: `mcp.NewServer(&mcp.Implementation{Name: "youtube-music-mcp", Version: "0.1.0"}, nil)`
      - Store logger and ytClient for future tool registration (Phase 2)
      - Return Server struct

    Create `Run(ctx context.Context) error`:
      - Log "starting MCP server" at INFO level
      - Call `mcpServer.Run(ctx, &mcp.StdioTransport{})` — this blocks until shutdown
      - Return error if Run fails

    NOTE: The MCP Go SDK API may differ slightly from research examples. Check actual package exports:
    - The server creation may use `mcp.NewServer()` or `server.NewMCPServer()` — adapt to actual API
    - Stdio transport may be in a sub-package (e.g., `mcp/stdio`) — check imports
    - Tool registration API may use `mcp.AddTool()` or `server.AddTool()` — defer to Phase 2 but ensure Server struct exposes what's needed

    If the MCP SDK API differs from research patterns, adapt accordingly. The key requirement is: create an MCP server that communicates via stdin/stdout using JSON-RPC. Consult the SDK source or documentation if the patterns in research don't compile.

    **cmd/server/main.go:**

    Entry point that wires everything together. Execution order:
    1. `log.SetOutput(os.Stderr)` — FIRST statement, before anything else
    2. Create slog logger: `slog.New(slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{Level: slog.LevelInfo}))`, set as default
    3. Load config: `config.Load()` — exit 1 on error with log
    4. Create OAuth2 config: `auth.NewOAuth2Config(cfg.GoogleClientID, cfg.GoogleClientSecret, cfg.OAuthRedirectURL)`
    5. Create token storage: `auth.NewFileTokenStorage(auth.DefaultTokenPath())`
    6. Authenticate: `auth.Authenticate(ctx, oauthCfg, storage, cfg.OAuthPort, logger)` — exit 1 on error
    7. Create YouTube client: `youtube.NewClient(ctx, httpClient)` — exit 1 on error
    8. Validate auth: `ytClient.ValidateAuth(ctx)` — log channel name at INFO level, exit 1 on error
    9. Create MCP server: `server.NewServer(logger, ytClient)`
    10. Run MCP server: `srv.Run(ctx)` — exit 1 on error

    Use `context.Background()` for the main context. Handle OS signals (SIGINT, SIGTERM) with `signal.NotifyContext` for clean shutdown.

    CRITICAL: No fmt.Printf, fmt.Println, or any stdout writes except through the MCP server's JSON-RPC transport. Everything else goes to stderr via slog logger.
  </action>
  <verify>
    - `go build ./...` compiles all packages without errors
    - `go vet ./...` reports no issues
    - `go build -o bin/youtube-music-mcp ./cmd/server/` produces binary
    - Binary exists at `bin/youtube-music-mcp`
  </verify>
  <done>YouTube client wraps API with auth validation. MCP server creates and runs via stdio. Main entry point wires config -> auth -> youtube -> MCP server in correct order. Binary builds successfully.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify end-to-end OAuth2 flow and MCP server startup</name>
  <files>cmd/server/main.go</files>
  <action>
    Human verification checkpoint. What was built: Complete MCP server with OAuth2 authentication and YouTube API validation. On first run, the server prompts for Google authorization via browser. On subsequent runs, it loads the saved token and skips the auth prompt. After authentication, it validates access by fetching the user's YouTube channel name, then starts the MCP server.

    Resume signal: Type "approved" if both runs work correctly, or describe any issues encountered.
  </action>
  <verify>
    **Prerequisites:**
    1. Create Google Cloud project with YouTube Data API v3 enabled
    2. Create OAuth 2.0 Client ID (type: Web application) with redirect URI `http://localhost:8080/callback`
    3. Configure OAuth consent screen (add yourself as test user if in Testing status)
    4. Copy credentials to `.env` file (copy from `.env.example`)

    **First run (fresh auth):**
    1. Delete any existing token: `rm -f ~/.config/youtube-music-mcp/token.json`
    2. Run: `go run ./cmd/server/ 2>server.log`
    3. Check `server.log` — should see auth URL printed
    4. Visit the auth URL in browser, authorize with Google account
    5. Browser should show "Authorization successful!" message
    6. Check `server.log` — should see your YouTube channel name logged
    7. Verify token saved: `ls -la ~/.config/youtube-music-mcp/token.json` (should exist with 0600 permissions)
    8. Kill the server (Ctrl+C)

    **Second run (cached token):**
    1. Run again: `go run ./cmd/server/ 2>server.log`
    2. Check `server.log` — should NOT prompt for auth, should log channel name directly
    3. Kill the server (Ctrl+C)

    **Expected behavior:**
    - First run requires browser authorization, second run uses cached token
    - Channel name appears in logs on both runs
    - No output to stdout except MCP JSON-RPC messages (server.log captures stderr)
    - Token file has restricted permissions (0600)
  </verify>
  <done>User confirms: first run completes OAuth flow via browser, second run uses cached token, YouTube channel name appears in both runs, no stdout pollution.</done>
</task>

</tasks>

<verification>
1. `go build -o bin/youtube-music-mcp ./cmd/server/` — binary builds
2. First run with no token prompts for OAuth authorization via browser
3. Authorization completes, token saved to `~/.config/youtube-music-mcp/token.json`
4. YouTube channel name logged (proves API access works)
5. Second run uses cached token (no auth prompt)
6. All log output goes to stderr, stdout reserved for MCP JSON-RPC
7. MCP server starts after authentication (not before)
</verification>

<success_criteria>
- Binary builds and runs without errors
- OAuth2 flow completes: user authorizes in browser, callback receives code, token is exchanged and saved
- Token persists across restarts (no re-auth needed)
- YouTube API auth validation succeeds (channel name logged)
- MCP server starts via stdio transport after authentication
- Clean shutdown on SIGINT/SIGTERM
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-02-SUMMARY.md`
</output>
